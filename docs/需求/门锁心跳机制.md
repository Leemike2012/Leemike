# 门锁心跳机制

## 门锁心跳的初始化操作

门锁在安装到门上之前, 会人工往门锁里写入旅店ID, 房间号和密钥.

门锁第一次向服务器发送心跳请求时, 会缺省掉token, 作为向服务器申请的初始化请求. 发送请求如下格式:

```json
{
    "token": "",
    "timestamp": "时间戳. 格式: YYYYMMDDHHMMSS",
    "hotel": "旅店的uuid",
    "room": "房间号",
    "sign": "token+hotel+room+时间戳+密钥的MD5"
}
```

服务器在接受到缺失token的门锁心跳请求后, 会认为是第一次请求, 做如下操作:

1. 根据旅店uuid和房间号, 从缓存中拿到密钥: `hget 旅店uuid+房间号 key` (如果用uuid和房间号定位不到房间数据, 则认为是恶意攻击)
2. 根据签名规则, 用请求提供的参数和从缓存中拿到的密钥, 生成md5签名. 如果服务端签名和请求中的签名一致, 继续往下执行逻辑. 不一致则结束处理(当成恶意网络攻击, 真实线上场景中需要进行其他处理.)
3. 请求的时间戳参数和当前时间比对, 如果超过了超时设定, 则不进行后续处理.
4. 随机生成一个UUID, 作为返回给门锁的token. 把token写入缓存.
5. 把房间号和旅店的uuid作为key, **当前系统时间**作为value, 写入缓存.

门锁心跳数据以哈希表的形式写入缓存, 结构如下:

```json
{
    "旅店uuid+房间号":{
        "key": "服务端启动时, 扫描房间表,从房间表中的seed_key初始化", 
        "token": "UUID",
        "timestamp": "YYYYMMDDHHMMSS"
    }
}
```

## 门锁的心跳请求(heartbeat)

门锁拿到了token后, 根据设定好的时间间隔, 定期向服务器发送心跳. 服务器拿到心跳请求后, 确认门锁客户端存活.

门锁发送请求:

```json
{
    "token": "从服务器拿到的token",
    "timestamp": "时间戳. 格式: YYYYMMDDHHMMSS",
    "hotel": "旅店的uuid",
    "room": "房间号",
    "sign": "token+hotel+room+时间戳+密钥的MD5"
}
```

服务器接受到心跳请求后:

1. 根据旅店uuid和房间号, 从缓存中拿到密钥. `hget 旅店uuid+房间号 key`
2. 根据签名规则, 用请求提供的参数和从缓存中拿到的密钥, 生成md5签名. 如果服务端签名和请求中的签名一致, 继续往下执行逻辑. 不一致则结束处理(当成恶意网络攻击, 真实线上场景中需要进行其他处理.)
3. 请求的时间戳参数和当前时间比对, 如果超过了超时设定, 则不进行后续处理.
4. 使用旅店uuid和房间号作为key, 从缓存中取出token, 和请求中的token进行比对,一致, 继续往下执行逻辑. 不一致则结束处理.
5. 用**当前系统时间**更新掉缓存中的时间戳: `hset 旅店uuid+房间号 timestamp 当前系统时间`

我是孙艺恒


 